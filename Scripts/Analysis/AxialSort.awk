#=============================================================================#
#                                                                             #
#    AxialSort.awk                                                            #
#    24 November 2014                                                         #
#    Copyright W. Ryssens & M. Bender                                         #
#    in case of trouble, take it easy ...                                     #
#    and (please) let me know                                                 #
#                                                                             #
#=============================================================================#
#                                                                             #
#    Sort single-particle tables generated by MOCCa.spectra into tables by    #
#    the approximate Jx/y/z projection. Use only for axial calculations.      #
#                                                                             #
#    Note that the script is not foolproof and may require extra manual labor # 
#                                                                             #
#=============================================================================#
BEGIN{
    
    i    = 0
    iq   = 0
    kmax = 0
    kold = 0
   ikold = 0
} 

{       
    if(direction=="1"){
        ind =  9
    }
    if(direction=="2"){
        ind = 10
    }
    if(direction=="3" || direction==""){
        ind = 11
    }
    
    #------------------------------------------------------
    # Determine the file-name
    if ( NR == 1 ) { 
        lengthfilename = length(FILENAME);
        prefix = substr(FILENAME,1,lengthfilename-4);
        #print "\n filename = " prefix "\n";
        header = $0
    }
    
    if (NR !=1 && NF !=1 && $2 != ignore) {
        iq += 1 
        
        kkk = $ind
        if (TRC == 1){
            if ($3 == 0) {
        
                if (  -0.3 < kkk && kkk <  1.2 ) { twok =  1.0 ; k =  1 ; } ;
                if (   1.2 < kkk && kkk <  3.2 ) { twok =  5.0 ; k =  5 ; } ;
                if (   3.4 < kkk && kkk <  5.2 ) { twok =  9.0 ; k =  9 ; } ;
                if (   5.4 < kkk && kkk <  7.2 ) { twok = 13.0 ; k = 13 ; } ;
                if (   7.4 < kkk && kkk <  9.2 ) { twok = 17.0 ; k = 17 ; } ;
                if (   9.4 < kkk && kkk < 11.2 ) { twok = 21.0 ; k = 21 ; } ;
                if (  -2.5 < kkk && kkk < -0.4 ) { twok =  3.0 ; k =  3 ; } ;
                if (  -4.2 < kkk && kkk < -2.6 ) { twok =  7.0 ; k =  7 ; } ;
                if (  -6.2 < kkk && kkk < -4.4 ) { twok = 11.0 ; k = 11 ; } ;
                if (  -8.2 < kkk && kkk < -6.7 ) { twok = 15.0 ; k = 15 ; } ;
                if ( -10.2 < kkk && kkk < -8.7 ) { twok = 19.0 ; k = 19 ; } ;
            }
            else{
                twok = $3
                k    = $3
            }
        }
        else if (TRC != 1.0) {
            print "Can't do TR breaking sortings yet'"
            exit
        }
        k = twok;
        
        if ( k > kmax ) {
            kmax = k;
        }
        
        ikmax[iq,k] += 1;
        ik = ikmax[iq,k];
        if ( ik > kkmax[k] ) {
            kkmax[k] = ik;
        }
        kold  = k;
        ikold = ik;
        
        id[iq,i]   = i
        d[iq,k,ik] = $0
    }
    else if ( NF == 1 && NR !=1)
    {
        i    += 1;
        if ( iq > iqmax ) {
          iqmax = iq;
        }
        iq    = 0;
    }
}

END{
    printf(" i  = %4.0f levels found \n",i);
    printf(" iq = %4.0f deformations \n",iqmax);
    printf(" k  = %4.0f largest k found \n",kmax);

    k = -1;
    ksum = 0;
    while ( k < kmax+1 ) {
        k += 2;
        printf(" ik = %4.0f levels with k = %4.0f \n",kkmax[k],k);
        ksum += kkmax[k];
    }
    printf(" ksum = %4.0f levels found \n",ksum);
    
    k  = 1;
    while ( k < kmax+1 ) {
        printf( header "\n") > "tmp";
        ik = 1
        while ( ik < kkmax[k]+1 ) { 
            iq = 1;
            while ( iq < iqmax+1 ) {
                if ( d[iq,k,ik] != "" ) {
                    printf(d[iq,k,ik]) > "tmp"
                    printf("\n") > "tmp"
                
                }
                iq += 1;
            }
            printf("*\n") >> "tmp" ;
            ik += 1; 
        }
        close("tmp");
        command = "mv tmp "prefix".k="k".tab" ;
        system(command);
        k += 2;
    }
}
