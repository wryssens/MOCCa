#===============================================================================
# Script that does the best it can to identify single-particle states from MOCCa
# output, based on the value of <Jz>, which is an approximate quantum number.
#
#
#===============================================================================
import numpy as np
from tokenizer import tokenizer


def Sort(fname, KMAX=15):
    #============================================================
    # STEP 1
    #   Read a table of spwfs generated by MOCCa.spectra.awk
    #   into an array of all of the spwfs
    tokens = tokenizer(fname)
    tokens.next() # Skip the first line
    spwfs  =[np.loadtxt(A) for A in tokens]

    #============================================================
    # STEP 2
    # Find all of the points and put them onto our mesh.
    column = 9

    spwf = spwfs[0]
    nwt          = len(spwfs)
    deformations = range(len(spwf[:,0]))

    # Precision defined for 'unambiguous' cases
    Prec = 10**-2

    Jz= np.zeros((nwt, len(deformations)))
    E = np.zeros((nwt, len(deformations)))
    Mesh = np.zeros((nwt,len(deformations),3))
    for i in range(nwt):
        spwf = spwfs[i]
        for j in deformations:
            Jz[i,j] = spwf[j,column]
            E[i,j]  = spwf[j,6]
            Mesh[i,j,0] = 2*Jz[i,j]
            Mesh[i,j,1] =    E[i,j]
            Mesh[i,j,2] =        0

    #============================================================
    # STEP 3
    #   For every value of K up to KMAX construct the mesh of
    #   points we can be sure of (up to precision PREC)
    nK = 1
    # count the number of meshes we need
    for K in range(1, KMAX+1, 2):
        nK = nK + 1

    KMesh = np.zeros((nwt,len(deformations),2,nK))
    for K in range(0,nK):
        # For every deformation, put in the points that we can
        # identify, in the order of their energy.
        for j in deformations:
            index = 0
            for i in range(nwt):
                if( abs(2*K +1 - abs(Mesh[i,j,0])) < Prec ):
                    KMesh[index,j,0:2,K] = Mesh[i,j,0:2]
                    index = index +1

	#============================================================
	# STEP 4:
	#   Identify chains that are complete and remove them from
	#   consideration.
    Chain = np.zeros((nwt,nK,2))
    for K in range(0,1):
        for i in range(nwt):
            Chain[i,K,0:2] = 1
            for j in deformations[:-1]:
                if(abs(KMesh[i,j,0,K] - KMesh[i,j+1,0,K]) > 0.2):
                    Chain[i,K,0] = 0
                if(abs(KMesh[i,j+1,1,K] - KMesh[i,j+1,1,K]) > 3.0) :
                    Chain[i,K,1] = 0
            if (Chain[i,K,0] == 1):
                print 'Link ok', i,2*K+1
            else:
                print 'link broken', i,2*K+1

