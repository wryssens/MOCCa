import numpy as np
from tokenizer import tokenizer

def distance(p,q):
    # Definition of distance function
    if (abs(p[0] - q[0]) > 1) :
        return 10000000000
    else:
        return 10*(p[0] - q[0])**2 + (p[1] - q[1])**2
    
def Sort(fname, KMAX=15):
    #============================================================
    # STEP 1
    #   Read a table of spwfs generated by MOCCa.spectra.awk
    #   into an array of all of the spwfs
    tokens = tokenizer(fname)
    A = tokens.next() # Skip the first line
    
    with open(fname, 'r') as f:
        header = f.next()

        
    Ecolumn = 6
    Jcolumn = 9
    prefix  = fname.replace('.tab', '') 
    
    # This is a list of length NWT of a set of wavefunctions at every 
    # deformation
    spwfs  =[np.loadtxt(A) for A in tokens]
    
    spwf         = spwfs[0]
    nwt          = len(spwfs)
    deformations = range(len(spwf[:,0]))
    info         = len(spwf[0,:])
    Prec = 0.05
    
    #Make new array out of all the data
    # Dimension 1: deformation
    # Dimension 2: values of the SPWF
    # Dimension 3: number of SPWF in the deformation block
    spwfs        = np.dstack(spwfs)
    
    #============================================================
    # STEP 2
    #   Choose a point on the first deformation and find a
    #   minimal distance path to the other side.
    Chains=[]
    Taken =[]
    for i in range(nwt):
        chain={}
        chain[0] = i
        totald=0
        current=i
        for j in deformations[:-1]:
            mind       = 100000
            for k in range(nwt):
                if( (j+1,k) not in Taken):
                    d =distance( (spwfs[j,Jcolumn,current], spwfs[j,Ecolumn,current]), (spwfs[j+1,Jcolumn,k],spwfs[j+1,Ecolumn,k]))
                    if (d < mind):
                        mind = d
                        mini = k
            totald=totald + mind
            chain[j+1] = mini
            current = mini
            Taken.append((j+1,mini))
            
        Chains.append(chain)
    #=============================================================
    # STEP 4
    #   Identify the chains with Jz
    for K in range(1,KMAX,2):
      print K
      with open('%s.k=%d.tab'%(prefix,K), 'w') as f:
        f.write(header)
        for i in range(len(Chains)):
            chain = Chains[i]
            
            if ( abs( abs(2*spwfs[0,Jcolumn,chain[0]]) - K) < Prec ):
                for j in deformations:
                    for k in range(info):
                        f.write(' %8.3f '%spwfs[j,k,chain[j]])
                    f.write('\n')    
                f.write('*\n')
