#-------------------------------------------------------------------------------
# Python module for plotting data generated by MOCCa and the analysis scripts
#    MOCCa.spectra.awk
#    AxialSort.awk
#
# Matplotlib is our plotting engine of choice
#
# Files from a set of runs should be organized as 
#     PREFIX        e.tab
#     PREFIX       ef.tab
#     PREFIX         .tab
#
# etc...
#-------------------------------------------------------------------------------

import numpy as np
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt
import glob
from cycler import cycler

def MOCCaPlot(XARG, YARG, PREFIX, AXIS=None, INTERPOLATE=-1):
    #===========================================================================
    # Function that plots two values obtained in a set of data files, labelled 
    # by PREFIX, onto the axes passed into the routine.
    # Currently recognized options for XARG and YARG
    # 
    # 'E'   the energy from functional
    # 'Q20' <Q20_t> in fm^2
    #===========================================================================
    
    #Default to current axis
    if AXIS is None:
        AXIS = plt.gca()
    
    if(XARG=='Q20') :
        xlabel =r'$\langle \hat{Q}_{20} \rangle$ (fm$^2$)'
        xfname =PREFIX + '.t.qlm.tab'
        xcolumn=1
    else :
        print 'YARG not recognized'
        return
        
    if(YARG=='E') :
        ylabel =r'E (MeV)'
        yfname =PREFIX + '.e.tab'
        ycolumn=1
        normy  =1
    else :
        print 'YARG not recognized'
        return

    dataX=np.loadtxt(xfname,skiprows=1)
    dataY=np.loadtxt(yfname,skiprows=1)
    
    xdata=dataX[:,xcolumn]
    ydata=dataY[:,ycolumn]
    
    if(INTERPOLATE > 0):
        f     = interp1d(xdata, ydata,kind='cubic')
        interx= np.arange(min(xdata), max(xdata), INTERPOLATE) 
        
        ydata = f(interx)
        xdata = interx
    
    if(normy == 1) :
        ydata = ydata - min(ydata)
    
    AXIS.plot(xdata,ydata)
    
    AXIS.set_xlabel(xlabel)
    AXIS.set_ylabel(ylabel)

################################################################################
#
# Custom tokenizer for spwf tables.
#
def tokenizer(fname):
    with open(fname) as f:
        chunk = []
        for line in f:
            if (line.startswith('*')):
                yield chunk
                chunk = []
                continue
            chunk.append(line)   
################################################################################
def Nilsson(PREFIX, BASIS, ISO, PAR, SIG, KMAX=0, AXIS=None, INTERPOLATE=-1):

    #Default to current axis
    if AXIS is None:
        AXIS = plt.gca()
    
    xfname=PREFIX + '.t.qlm.tab'
    dataX=np.loadtxt(xfname,skiprows=1)
    xdata = dataX[:,2]
    
    fermifname=PREFIX + '.ef.tab'
    if(ISO == 'neutron'):
        fermicolumn=1
    else :
        fermicolumn=2
    fermidata = np.loadtxt(fermifname, skiprows=1)
    fermi     = fermidata[:,fermicolumn]
    
    AXIS.plot(xdata, fermi, 'k-.', label='$e_f$')
    
    if(INTERPOLATE > 0):
        interx= np.arange(min(xdata), max(xdata), INTERPOLATE) 
           
    colors   = ['b', 'r', 'c', 'g','k']  
            
    for P in PAR:
        if (P == '-1'):
            linestyle = '--'
        else:
            linestyle = '-'
            
        for S in SIG:
            fnametemp=PREFIX + '.' + BASIS + '.' + ISO + '.' + 'par=' + P + '.' + 'sig=' + S 
            
            for K in range(1,KMAX+1,2):
                
                fname = fnametemp + '.k=%d.tab'%K
                c = colors[(K-1)/2]
                
                tokens = tokenizer(fname)
                tokens.next()
                spwfs = [np.loadtxt(A) for A in tokens]
                for i in range(len(spwfs)):
                    spwf = spwfs[i]
                    try:
                        ydata = spwf[:,6]
                    except:
                        continue
                    if(INTERPOLATE > 0):
                        try:
                            f     = interp1d(dataX[:,2], ydata, kind='cubic')
                        except:
                            continue
                        ydata = f(interx)
                        xdata = interx
                   
                    try:
                        if(i == 0 and PAR.index(P) == 0):
                            AXIS.plot(xdata, ydata, c+linestyle, label=r'$J_z = \frac{%d}{2}$'%K)
                        else:
                            AXIS.plot(xdata, ydata, c+linestyle)
                    except ValueError:
                        continue
    AXIS.set_xlabel(r'$\beta_{20}$')
    AXIS.set_ylabel(r'E (MeV)')
