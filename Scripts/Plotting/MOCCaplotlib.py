#-------------------------------------------------------------------------------
# Python module for plotting data generated by MOCCa and the analysis scripts
#    MOCCa.spectra.awk
#    AxialSort.awk
#
# Matplotlib is our plotting engine of choice
#
# Files from a set of runs should be organized as 
#     PREFIX        e.tab
#     PREFIX       ef.tab
#     PREFIX         .tab
#
# etc...
#-------------------------------------------------------------------------------

import numpy as np
from scipy.interpolate import interp1d
from tokenizer import *
import matplotlib.pyplot as plt
import glob
import sys

def MOCCaPlot(XARG, YARG, PREFIX, AXIS=None, INTERPOLATE=-1, LABEL=None, NORMY=1, PC=1, LINESTYLE='-', MARKER=''):
    #===========================================================================
    # Function that plots two values obtained in a set of data files, labelled 
    # by PREFIX, onto the axes passed into the routine.
    # Currently recognized options for XARG and YARG
    # 
    # 'E'   the energy from functional
    # 'Q20' <Q20_t> in fm^2
    #===========================================================================
    
    #Default to current axis
    if AXIS is None:
        AXIS = plt.gca()
    
    if(XARG=='Q20') :
        xlabel =r'$\langle \hat{Q}_{20} \rangle$ (fm$^2$)'
        xfname =PREFIX + '.t.qlm.tab'
        xcolumn=1
        if(PC != 1) :
            xcolumn = 3
    elif(XARG=='B20') :
        xlabel =r'$\beta_{20}$ '
        xfname =PREFIX + '.t.qlm.tab'
        xcolumn=2
        
        if(PC != 1) :
            xcolumn = 4
    elif(XARG=='B30') :
        if(PC == 1) :
            print "Can't plot Q30 when parity is conserved."
            sys.exit()
        
        xlabel =r'$\beta_{30}$ '
        xfname =PREFIX + '.t.qlm.tab'
        xcolumn=8
    elif(XARG=='B32') :
        if(PC == 1) :
            print "Can't plot Q30 when parity is conserved."
            sys.exit()
        xlabel =r'$\beta_{32}$ '
        xfname =PREFIX + '.t.qlm.tab'
        xcolumn=10
    elif(XARG=='OmZ') :
        xlabel =r'$\omega_{z}$ (MeV $\hbar^{-1}$) '
        xfname =PREFIX + '.e.tab'
        xcolumn=10
    elif(XARG=='JZ') :
        xlabel =r'$\langle \hat{J}_{z} \rangle$ ($\hbar$)'
        xfname =PREFIX + '.e.tab'
        xcolumn=11
    else :
        print 'XARG not recognized'
        return
        
    if(YARG=='E') :
        ylabel =r'E (MeV)'
        yfname =PREFIX + '.e.tab'
        ycolumn=1
        derivY = 0
    elif(YARG=='B40') :
        ylabel =r'$\beta_{40}$ '
        yfname =PREFIX + '.t.qlm.tab'
        if(PC == 1) :
            ycolumn=6
        else:
            ycolumn=12
        derivY = 0
    elif(YARG=='B42') :
        ylabel =r'$\beta_{42}$ '
        yfname =PREFIX + '.t.qlm.tab'
        if(PC == 1) :
            ycolumn=8
        else:
            ycolumn=14
        derivY = 0
    elif(YARG=='JZ') :
        ylabel =r'$\langle \hat{J}_{z} \rangle$ ($\hbar$)'
        yfname =PREFIX + '.e.tab'
        ycolumn=11
        derivY = 0
    elif(YARG=='I2') :
        # Dynamical moment of inertia. 
        ylabel =r'$\mathcal{I}^{(2)}$ ($\hbar^2$ MeV$^{-1}$)'
        yfname =PREFIX + '.e.tab'
        ycolumn=11
        derivY = 1 
    elif(YARG=='B20') :
        ylabel =r'$\beta_{20}$ '
        yfname =PREFIX + '.t.qlm.tab'
        ycolumn=2
        derivY=0
        if(PC != 1) :
            ycolumn = 4      
    else :
        print 'YARG not recognized'
        return

    dataX=np.loadtxt(xfname,skiprows=1)
    dataY=np.loadtxt(yfname,skiprows=1)
    
    xdata=dataX[:,xcolumn]
    ydata=dataY[:,ycolumn]
    
    if(derivY == 1) :
        #=====================================================
        #Flag that tells us to take the finite difference of Y
        # The dynamical moment of inertia is a good example
        deriv = np.zeros((len(ydata)-2))
        for i in range(0,len(ydata)-2):
            deriv[i] = ( ydata[i+1] - ydata[i])/(xdata[i+1] - xdata[i])
        ydata = deriv
        xdata = xdata[1:-1]
         
    if(INTERPOLATE > 0):
        f     = interp1d(xdata, ydata,kind='cubic')

        interx= np.arange(min(xdata), max(xdata), INTERPOLATE) 

        ydata = f(interx)
        xdata = interx
    
    if(NORMY == 1) :
        ydata = ydata - min(ydata)
    
    AXIS.plot(xdata,ydata, label=LABEL, linestyle=LINESTYLE, marker=MARKER)
    AXIS.set_xlabel(xlabel)
    AXIS.set_ylabel(ylabel)
    
    return (xdata[np.argmin(ydata)], min(ydata))

################################################################################
def Nilsson(PREFIX, BASIS, ISO, PAR, SIG, KMAX=0, AXIS=None, INTERPOLATE=-1):

    #Default to current axis
    if AXIS is None:
        AXIS = plt.gca()
    
    xfname=PREFIX + '.t.qlm.tab'
    dataX=np.loadtxt(xfname,skiprows=1)
    xdata = dataX[:,2]
    
    fermifname=PREFIX + '.ef.tab'
    if(ISO == 'neutron'):
        fermicolumn=1
    else :
        fermicolumn=2
    fermidata = np.loadtxt(fermifname, skiprows=1)
    fermi     = fermidata[:,fermicolumn]
    
    AXIS.plot(xdata, fermi, 'k-.', label='$e_f$')
          
    colors   = ['b', 'r', 'c', 'g', 'k', 'm', 'burlywood', 'chartreuse']  
            
    for P in PAR:
        if (P == '-1'):
            linestyle = '--'
        else:
            linestyle = '-'
            
        for S in SIG:
            fnametemp=PREFIX + '.' + BASIS + '.' + ISO + '.' + 'par=' + P + '.' + 'sig=' + S 
            
            if(KMAX !=0):
                #===============================================================
                # Axial case
                for K in range(1,KMAX+1,2):
                    
                    fname = fnametemp + '.k=%d.tab'%K
                    c = colors[(K-1)/2]
                    
                    try:
                        tokens = tokenizer(fname)
                        tokens.next()
                        spwfs = [np.loadtxt(A) for A in tokens]
                    except IOError:
                        #This happens if KMAX is too big
                        break 
                
                    for i in range(len(spwfs)):
                        spwf = spwfs[i]
                        
                        try:
                            ydata = spwf[:,6]
                            indexes = [int(x)-1 for x in spwf[:,1]]
                        except IndexError:
                            # Just ignore spwfs that are a single point
                            continue
                        
                        xdata   = dataX[indexes,2]
                        
                        if(INTERPOLATE > 0):
                            try:
                                f     = interp1d(xdata, ydata, kind='cubic')
                            except:
                                continue
                            interx= np.arange(min(xdata), max(xdata), INTERPOLATE) 
                            ydata = f(interx)
                            xdata = interx
                       
                        try:
                            if(i == 0 and P == PAR[0] ):
                                AXIS.plot(xdata, ydata, c+linestyle, label=r'$J_z = \frac{%d}{2}$'%K)
                            else:
                                AXIS.plot(xdata, ydata, c+linestyle)
                        except ValueError:
                            continue
            else:
                print 'No plotting defined for nonaxial case yet'
                sys.exit()
                    
                
    AXIS.set_xlabel(r'$\beta_{20}$')
    AXIS.set_ylabel(r'E (MeV)')
